<!DOCTYPE html>
<html>
<head>
<title>Projects - Daniel Filler</title>

<meta content="width=device-width, initial-scale=1" name="viewport" />
<link rel="stylesheet" type="text/css" href="../css/style.css">
<link rel="stylesheet" type="text/css" href="../apps/apps_style.css">
<link rel="icon" href="../images/icon.png">

</head>
<body>

	<div class="page">
		<div class="topnav">
			<div class="topnav_wrapper">
			<ul>
			  <a href="../html/home.html">Home</a>
			  <a href="../html/about.html">About</a>
			  <a href="../html/projects.html" id="topnav_selected">Projects</a>
			  <a href="../html/contact.html">Contact</a>
			</ul>
			</div>
		</div>
		<div class="mySlides fade">
			<div class="page-title"><a class="title-link" href="https://dfclutch.github.io/apps/graphs">Graph Algorithms</a></div>
			<div class="content">
			A fully front-end based, live-tweakable, set of graph algorithms intended for education. written in pure javascript for easy development/deployment using github pages. The project is constantly in progress as I continually add more graph types, algorithms, etc. Far more information is availible on the website.<p>
			<input class="control_button" type="button" value="Run Again!" onclick="run_bfs()">
			<canvas id="viewport" width="600" height="600">
        	</canvas><br>
        	<p>
        		In the example animation above (a breadth first search), the graph is randomly produced every time the algorithm is run. But to make a visually informative graph, constructing purely random nodes and edges is not adequate. The hardest problem to solve in building this site was creating an algorithm to generate "nice" looking graphs that provide valuable information about why some algorithms are better for some applications than others. The eventual result of this design process was an algorithm I call <em>soft k-nearest neighbor.</em> the SKNN algorithm first selects a random number of edges in the range [1:k] for each node. The edges are connected to nearby nodes, simulating a real-life network. These nearby neighbors are selected randomly from the set of the <em>k * 1.5</em> nearest nodes. This produces a graph which looks and behaves like real life networks, where closely connected nodes are more likely to be connected, but some farther adjacencies are possible.
        	</p>
			</div>
		</div><div class="mySlides fade">
			<div class="page-title"><a class="title-link" href="https://java-docs.herokuapp.com">Java Docs</a></div>
			<div class="content">
			A work in progress, full-stack web app for documenting complex coffee recipes. For specialty coffee enthusiasts, coffee recipes are more like scientific procedures than putting a couple scoops of ground coffee in a machine and pressing start. Different brewing methods (i.e. French Press, Espresso, etc.) require specifying different information. The coffee, water temperature, how many seconds you "bloom" the grounds, and many other factors contribute to the coffee that ends up in your cup. With all these variables, most coffee enthusiasts take an engineer-like approach to developing recipes, constantly tweaking and altering grind settings and recipe timing to get the perfect extraction. Java Docs (a name I will use until Oracle sends me a cease and disist) attempts to provide a formalized way to document recipes. This is a challenge because even given a specific brew method, people's techniques vary wildly. Compromises must be made between providing a recipe format with a high amount of granularity and not constricting the type of recipes that can be made.<br>
			The application is built using a MongoDB, ExpressJS, ReactJS, and NodeJS (MERN) stack and deployed using Heroku. I chose these technologies for a few reasons. First, Node and React are teachnologies that I have worked with professionally in my internship, and are two of the most important technologies in modern web development. Further, I simply love writing JavaScript. I was also able to build and deploy that app completely for free, which is convinient, because I am only a college student making a TA salary.<br>
			Currently, the app is in the early stages of development. I have provided basic CRUD functionality for creating, editing, and deleting recipes. Future plans for the site include adding user accounts with JWT authentication (another technology I have worked with at an enterprise level) and adding rating and favoriting features to recipes to record what works best for different beans. Eventually, I would like to apply my AI knowledge from my degree, using the data generated to produce models that can predict a good recipe given a certain bean and roast-level. <br>
			</div>
		</div>
	</div>
	<div class="footer">
		 	<button onclick="plusSlides(-1)">previous</button>
		 	<button onclick="plusSlides(1)">next</button>
	</div>

<script src="../js/slideshow_js.js"></script>
<script type="text/javascript" src="../apps/graph_src/animators.js"></script>
<script type="text/javascript" src="../apps/graph_src/graph.js"></script>
<script type="text/javascript" src="../apps/graph_src/graphics.js"></script>
<script type="text/javascript" src="../js/graphs_project.js"></script>
<script type="text/javascript" src="../apps/graph_src/constants.js"></script>
<script type="text/javascript" src="../apps/graph_src/state.js"></script>
<script type="text/javascript" src="../apps/graph_src/generate.js"></script>
<script type="text/javascript" src="../apps/graph_src/graph_node.js"></script>
<script type="text/javascript" src="../apps/graph_src/graph_edge.js"></script>
<script type="text/javascript" src="../apps/graph_src/frames.js"></script>
<script type="text/javascript" src="../apps/graphics/graphics.js"></script>
<script type="text/javascript" src="../apps/graph_src/utils.js"></script>
</body>
</html>
