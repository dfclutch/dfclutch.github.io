<html>
<head>
    <title>Algorithm Visualizations</title>
    <link rel="stylesheet" href="./apps_style.css">
</head>
<body>
<div class="title_blocK">
    <h1>Graph Algorithms</h1>
</div>
<div class="content">
    <div>
        <canvas id="viewport" width="700" height="600">
        </canvas>
    </div>
    <div class="controls">
        <div class="control_block">
            <div class="control_set">
                <h3>Graph Controls</h3>
                Branching Factor
                <input class="slider" type="range" id="branching" min="1" max="9">
                <br>
                Depth
                <input class="slider" type="range" id="depth" min="1" max="10">
                <br>
                Graph Density
                <input class="slider" type="range" id="density" min="1" max="10" step="1">
                <br>
                Node Size
                <input class="slider" type="range" id="node_size" min="1" max="10">
                <br>
                Speed
                <input class="slider" type="range" id="speed" min="0" max="499">

            </div>
        </div>
        <div class="control_block">
            <div class="control_set">
                <h3>Run Algorithms</h3>
                <input class="control_button" type="button" id="btn_1" value="This Does Nothing">
                <input class="control_button" type="button" id="btn_2" value="This Does Nothing">
                <input class="control_button" type="button" id="btn_3" value="This Does Nothing">
                <input class="control_button" type="button" id="btn_4" value="This Does Nothing">
            </div>
            <div class="control_set">
                <h3 id="text_output">text output</h3>
                <input class="control_button" type="button" id="new_graph" value="New Graph">
                <br>
            </div>
            <br>
        </div>
        <div class="control_block">
            <div class="control_set">
                <h3>Graph Type</h3>
                <input type="radio" name="graph_type" value="tree" checked="checked">
                Tree
                <input type="radio" name="graph_type" value="und_simple">
                Undirected
                <input type="radio" name="graph_type" value="dir_simple">
                <s>Directed</s>
                <input type="radio" name="graph_type" value="edge_weighted">
                <s>Edge Weighted</s>
                <br>
            </div>
        </div>
    </div>
</div>
<div class="info">
    <div class="info_block">
        <p>A set of live-animated, fully tweakable graph algorithm visualizations. The app is currently being fully
            rewritten for both code quality and performance. This is not up to the same spot as the old version - in
            terms of number of types of graphs and algorithms implemented on them. However, here are some of the plans I
            have for future development on this site:</p>
        <br>
        <em>Types of graphs</em>
        <ul>
            <li>Undirected Simple Graphs</li>
            <li>Directed Graphs</li>
            <li>Edge weighted (network flow graph)</li>
            <li>Nice Graph (grid node positions to be easier to see)</li>
        </ul>
        <em>Algorithms</em>
        <ul>
            <li>Breadth First/Depth First Search</li>
            <li>Maxflow (Ford Fulkerson probably)</li>
            <li>Hamiltonian Path</li>
            <li>Minimum Spanning Tree (Kruskal's)</li>
            <li>Some coloring algorithms</li>
        </ul>
    </div>

    <div class="info_block">
        <h2>Learning Corner</h2>
        <p><em><strong>Implementation:</strong></em></p>
        <p>
            This app is written in front-end only JavaScript. All animations are created live based on the state of the
            controller settings. This extremely <a href="https://en.wikipedia.org/wiki/Fat_client" class="in_text">thick
            client</a>
            design was chosen for a few reasons:<br>
        <ul>
            <li>I can host static sites with front-end JS for free on github pages</li>
            <li>Easier to implement instead of trying to maintain both a UI and Server codebase</li>
            <li>Makes the app more responsive</li>
        </ul>
        The code can be viewed <a href="https://github.com/dfclutch/dfclutch.github.io" class="in_text">here</a>. In
        short, the app relies on a central state object that is updated whenever the sliders/radio buttons are changed -
        much like the pattern used in Redux applications. The graph is represented as an object with an <a
            href="https://en.wikipedia.org/wiki/Adjacency_matrix" class="in_text"><em>Adjacency Matrix</em></a> to model
        the graph structure, and arrays of Node and Edge objects to represent the literal expression of the graph. Each animation
        is tied to a function which populates Frames, a property of the state, with many Graph objects, each colored
        (and eventually text-ed) differently to represent each step of the algorithm. When the animation is run, the
        Frames object is populated completely first, and then each Graph gets drawn with a certain amount of time in between each redraw.
        <p><em><strong>Search:</strong></em></p>
        <p>
            The first algorithms animations implemented on this site are basic <em><a
                href="https://en.wikipedia.org/wiki/Breadth-first_search" class="in_text">Breadth First Search</a></em>
            and <em><a
                href="https://en.wikipedia.org/wiki/Depth-first_search" class="in_text">Depth First Search</a></em>.
            These are the two
            most common algorithms for <a href="https://en.wikipedia.org/wiki/graph_traversal" class="in_text"><em>graph
            searching</em></a>. The algorithms start from an initial position (the root of the tree, or a random node in
            the simple graph) and searches for the goal node, marked in red. When watching the algorithm run some
            interesting properties can be observed.
        </p>
        <p>
            The algorithms behave differently depending on the situation they are searching. For example, if the node is
            in the first half of the bottom row of the tree, DFS will search significantly fewer nodes (marked in green
            after being visited) than BFS. Though if you animate the algorithm on the random undirected graph - which
            includes both cycles and much greater "depth" than the trees, BFS will generally take longer, though the
            eventual path to the goal node will often be <b>much</b> shorter than that of DFS.
        </p>
        <p>
            The differences between the behavior (which can be formally expressed in part by analyzing their asymptotic
            time and space complexity, see the linked articles above) make deciding between the two algorithms a
            critical choice when they are used in application. Graph traversal is a key part of many algorithms for
            things like web searching, network analysis, artificial intelligence, etc.
        </p>
    </div>
</div>
<script src="./src/jquery.min.js"></script>
<script type="text/javascript" src="./src/state.js"></script>
<script type="text/javascript" src="./src/graph.js"></script>
<script type="text/javascript" src="src/graph_node.js"></script>
<script type="text/javascript" src="src/graph_edge.js"></script>
<script type="text/javascript" src="./src/frames.js"></script>
<script type="text/javascript" src="./src/app.js"></script>
<script type="text/javascript" src="src/animators.js"></script>
<script type="text/javascript" src="./src/constants.js"></script>
<script type="text/javascript" src="./src/generate.js"></script>
<script type="text/javascript" src="./src/graphics.js"></script>
<script type="text/javascript" src="src/page_elements.js"></script>
<script type="text/javascript" src="src/buttons.js"></script>
<script type="text/javascript" src="src/utils.js"></script>
</body>
</html>
